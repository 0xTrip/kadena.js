---
title: Capability theory
description:
menu: Capability theory
label: Capability theory
order: 2
layout: full
tags: ['pact', 'capability theory', 'definitions']
---

# Capability theory

## Definitions

### "Standard" capability

Definition of standard capability _sc_ of domain _d_, which is the name of the
`defcap` whose parameters are _P_ and defines the predicate/"guard" function
_g_, which can compose/"import" other capabilities _C<sub>I</sub>_.

<div align="center">
  <strong>
    sc :: d = (P, g, C<sub>I</sub>)
  </strong>
</div>

### "Managed" capability

For _managed_ capability _mc_, it has all the features of _c_, plus it can
decompose _P_ into _free_ or "identifying" variables that further inform its
type, and _bound_ or "quantifying" variables that are computed in the manager
function _m_:

<div align="center">
  <strong>
    mc :: (d, P<sub>F</sub>) = (P<sub>B</sub>, g, m, C<sub>I</sub>)
  </strong>
</div>

### Module admin capability

"Module admin" describes a privilege escalation that is specified by the module
declaration itself, either as **keyset-based** or **governance-based**, the
latter requiring specification of a `defcap` to guard module upgrade.

Module admin capability _mm_ has a special type _a_, is parameterized by the
module name _n_, cannot be managed, allows composition, and specifies either
guard function g or keyset k.

<div align="center">
  <strong>
    mm :: a = (n, Either g k, C<sub>I</sub>)
  </strong>
</div>

### Unified capability definition

In practice, managed capabilities are uniform with standard capabilities with
only the presence of _m_ to differentiate them, with the operational suggestion
that _m_ should _match_ on _P<sub>F</sub>_ and _compute_ on _P<sub>B</sub>_.
Module admin remains its own subtype.

<div align="center">
  <strong>
    c :: d = (P, g, Maybe m, C<sub>I</sub>)
  </strong>
  <br />
  <strong>
    c :: a = (n, g, C<sub>I</sub>)
  </strong>
</div>

If _m_ is populated in _c d_, the capability is considered "managed".

### `defcap` as constructor and predicate

The `defcap` special form plays two roles: it resembles a standard `defun` with
a name, arguments and a body, which serves to implement the guard function _g_,
but it also specifies a "capability reference" that uniquely identifies some
inhabitant of _d_ parameterized by _P_.

When a `defcap` is used for module governance, it specifies _g_ only, as the
module name _n_ is inferred.

#### Capability reference constructor

The `defcap` construction operates as a constructor of a capability reference
_c\* d_:

<div align="center">
  <strong>P -> Maybe m -> c* d</strong>
</div>

#### Definition of _g_

`defcap` also defines the lambda function _g_ operating on environment E. In
addition to validating whatever is directly required to acquire the capability,
it can "compose" or import other capabilities _C<sub>I</sub>_. Lastly it is
_pure_ in that it cannot update database state.

<div align="center">
  <strong>
    g :: P -> E -> Either Error C<sub>I</sub>
  </strong>
</div>

As such, _g_ has the same shape as Pact's operation
`enforce-guard :: guard -> E -> Either Error ()`. We remark that _g_ is
therefore "both an enforcement and definintion of a guard".

### Capability slots

Capabilities are collected in _slots_, which are _scoped_ to indicate their
operational semantics. The slot _s_ stores the reference _c\* d_, scope _o_, and
any composed capability slots _S<sub>I</sub>_.

<div align="center">
  <strong>
    s = (o &isin; \{Managed | Stack | Composed\}, c* d, S<sub>I</sub>)
  </strong>
</div>

#### _Managed_ scope

Managed capabilities are said to be "installed" as they can only be constructed
and evaluated once. They are mutated by _m_ when code requests a capability of
matching domain _d_, described later.

#### _Stack_ scope

Stack capabilities are said to be "acquired" by user code, and are
scoped/managed by the call-stack at acquisition time.

#### _Composed_ scope

A composed capability inherits the scope of the composing/parent capability and
its slot inhabits parent _C<sub>I</sub>_.

### Manager function _m_

For a given domain _d_, the manager function takes the parameters of a managed
capability _P<sub>M</sub>_ and those of a requested stack capability
_P<sub>S</sub>_, which on success returns updated params for the managed
capability _P'<sub>M</sub>_. The function is a pure function that is not
intended to consider the environment, although this is not forbidden
operationally.

<div align="center">
  <strong>
    m :: P<sub>M</sub> -> P<sub>S</sub> -> Either Error P'<sub>M</sub>
  </strong>
</div>

NB the ideal presentation is _P<sub>M</sub><sup>B</sup> ->
P<sub>S</sub><sup>B</sup> -> Either Error P'<sub>M</sub><sup>B</sup>_, where
match has occurred on the free parameters.

### Signer/witness capability map

Signers/witnesses are associated with capability references as a map _W_ from
the witness _w_ to the associated capability references _C\*<sub>w</sub>_.

<div align="center">
  <strong>
    W = w -> C*<sub>w</sub>
  </strong>
</div>

### Runtime state _R_

The runtime _R_ stores two sets of capability slots, Managed (_S<sub>M</sub>_)
and Acquired (_S<sub>A</sub>_), the map of signer witnesses _W_, and a
collection to track "seen" managed capabilities \_C\*<sub>M</sub>.

<div align="center">
  <strong>
    R = (S<sub>M</sub>, S<sub>A</sub>, W, C*<sub>M</sub>)
  </strong>
</div>

### Acquired Capability Stack _S<sub>A</sub>_

_S<sub>A</sub>_ operates as a stack in keeping with the callstack-scope of
`with-capability`.

Operationally, it also accumulates _pending_ capabilities as a stack, to
properly handle nested composition, and secure in Pact's terminating design that
a failure means the stack being slightly inaccurate during capability
acquisition is of no consequence.

Post-validation, the stack is pruned as needed:

- composed are popped and installed into parent _S<sub>I</sub>_;
- managed are popped and inserted into _S<sub>M</sub>_;
- acquired are left on the stack. After body is executed, the stack is blindly
  popped.

## Operational semantics

### Installation of managed capabilities: `install-capability`

Managed capabilities are said to be _installed_ by one of two mechanisms:
`install-capability` or automatically when specified in _W_. Only managed
capabilities can be installed, so non-managed capabilities in _W_ are ignored.

#### Construct reference _c\*<sub>M</sub> d_.

Reference _c\*<sub>M</sub> d_ is either specified in the `install-capability`
call or already constructed in _W_.

#### Test for already installed -> no action

Managed capabilities are tracked in runtime _C\*<sub>M</sub>_ with their
initially-installed parameterizations to prevent duplicate installs. If this is
found, no action is taken.

#### Not installed -> track, run _g_.

_c\*<sub>M</sub> d_ is added to _C\*<sub>M</sub>_ for dupe install tracking.

Newly-installed references execute _g_ to validate install. Composed
capabilities are added to S<sub>I</sub> as normal, but are not "manageable"
themselves.

#### Successful install.

A new slot containing _c\*<sub>M</sub> d_ is added to _S<sub>M</sub>_.

#### Lifecycle of Managed capability

Managed capability stays in _S<sub>M</sub>_ for the entire transaction, although
it mutates per the manager function. The tracked reference in _C\*<sub>M</sub>_
is never mutated.

### Acquisition of stack-scoped capabilities: `with-capability`

The `with-capability` special form attempts to acquire a stack-scoped or
_acquired_ capability, which upon success executes a contained body form.

#### Construct reference.

The first argument of `with-capability` applies the `defcap` as a constructor to
create reference _c<sub>A</sub>\* d_.

#### Test for already acquired -> no action

If a slot with _c\*<sub>A</sub> d_ is already in _S<sub>A</sub>_, control
returns to the body form with no action.

#### Not acquired -> test managed

_S<sub>M</sub>_ is scanned for any managed slots for references of the same
domain _d_. For each, the associated manager function _m_ is executed. The first
to succeed wins. Order of execution is the natural order of the capability
references.

NB: Ideally, it should be tested for an exact match on _(d, P<sub>F</sub>)_ as
only one match should be possible, and that one _m_ function executed.

#### Execution of manager function _m_

For the installed capability _c<sub>M</sub>\* d_, and the requested stack
capability to acquire _c<sub>A</sub>\* d_, the manager function is invoked,
which upon success produces _c'<sub>M</sub>\* d_.

#### Success: update of slot _c<sub>M</sub>\* d_

The slot for _c<sub>M</sub>\* d_ is replaced with the _c'<sub>M</sub>\* d_
result from the manager function. Composed capabilities (_S<sub>I</sub>_) in
_c<sub>M</sub>\* d_ are "copied" into _S<sub>I</sub>_ in the requested
capability slot.

#### Failure: acquire fails

In a situation where a capability slot of matching domain _d_ was found but none
succeeded, the acquire operation fails.

#### No match on managed: acquire fails

If _d_ is managed but nothing was installed for _d_, acquire fails.

#### No match on non-managed: run _g_

If _d_ is not managed, _g_ is executed to validate acquisition.

#### Successful acquire.

If _m_ or _g_ succeeds, a new slot containing _c\*<sub>A</sub> d_ is added to
S<sub>A</sub>, and the body is executed.

#### Lifecycle of Acquired capability

Once the body of `with-capability` terminates, the slot for _c\*<sub>A</sub> d_
is popped off of _S<sub>A</sub>_ and terminates, along with any composed
capabilities in _S<sub>I</sub>_.

### Import of composed capabilities: `compose-capability`

Import, via `compose-capability` can only occur in _g_, so there is always a
"parent" capability slot ready to receive the capability in _C<sub>I</sub>_.

#### Construct reference.

The first argument of `compose-capability` applies the `defcap` as a constructor
to create reference _c<sub>I</sub>\* d_.

#### Run identically as for an acquired capability

The procedure from here on out is identical to a stack/acquired capability, with
the exception that on success no body form is executed, and failure causes the
parent to fail as well.

#### Successful compose

Install _c<sub>I</sub>\* d_ parent _C<sub>I</sub>_.

#### Lifecycle of composed capabilities.

Composed capabilities go out of scope/terminate with their parent capability.

### Testing capabilities: `require-capability`

`require-capability` looks for specified reference _c<sub>R</sub>\* d_ in
_S<sub>A</sub>_, including any composed capabilities. As such it does not modify
_R_ so is safe to use anywhere. Also, it does _not_ check _S<sub>M</sub>_, which
means that acquired capabilities are the only actual "enforcement" mechanism, as
possibly managed by caps in _S<sub>M</sub>_.

### Signature/Witness capabilities

#### Filtering keys from `enforce-keyset`

When `enforce-keyset` is invoked, matching signer witnesses are included if and
only if a capability in _C\*<sub>W</sub>_ is "in scope", which is anywhere in
_S<sub>M</sub>_ or _S<sub>A</sub>_ including all composed capabilities, as well
as any "pending" capabilities "coming into scope".

Note that since managed capabilities can only be installed once, those installed
by dint of being in _W_ are only validated against specified witnesses in _W_
once. Thus, specifying a managed capability for _w_ ensures that _w_ will only
be "used once".

### Module admin capability

A module admin capability _m a_ is an **automatically acquired and managed**
capability such that acquisition results in automatic install and the capability
effectively remains in scope for the rest of the transaction.

#### Automatic acquisition and management

Module admin is automatic in the following scenarios:

- Module upgrade.
- Direct access to module tables.
- Invocation of a module guard outside of module code.

#### Reference construction, installation

Reference _c\* a<sub>n</sub>_ is constructed. If a slot is already installed,
acquisition is trivially successful (ie, a trivial _m_ function). If not, a new
slot for _c\* a<sub>n</sub>_ is constructed, and guard is tested.

#### Guard execution

For keysets, this is simply enforcing the keyset. For governance function _g_,
the function is evaluated.

On success, slot for _c\* a<sub>n</sub>_ is installed (added to _S<sub>M</sub>_)
**and** acquired (pushed onto _S<sub>A</sub>_). The capability reference is also
added to "seen" collection _C\*<sub>M</sub>_.

#### Manual acquistion/require/reference not currently possible

Currently there is no way to manually acquire module admin. Whether the
mechanism is keyset or cap-based governance, while it is possible to
**replicate** governance in a separate capability, it is currently impossible to
**directly reference** module admin in code.

TODO without this, there is no way to bind a signer to module admin, so a key
with some other capability won't match this test. It is possible that the syntax
for caps in _W_ should admit a special syntax for indicating _c\*
a<sub>n</sub>_, namely the bare module name. This could also suffice for other
uses needing a module admin reference.

#### Automatic management

Management of module admin simply allows the capability to come into scope
anytime after first acquisition.

#### Rationale for "sticky" acquisition

Given the extreme power of module admin, it appears alarming that its scope is
so lenient. However the rationale is to give module administrators the most
power to perform tasks like data migration and threat mitigation, namely by
directly accessing database tables outside of module code. Also, module
governance is potentially expensive to grant, as in decentralized cases
involving tallying votes in the database, so not making this grant sticky can
result in prohibitive performance or gas usage by re-acquiring the capability.

Any attempt to allow extra-module code to have a mechanism to acquire module
admin manually makes it possible for third-party code to do so as well.
Conversely, requiring all administrator code to reside in the module burdens the
module author with properly securing those functions with module admin, which as
noted above is impossible currently, requiring duplicate methods.

We note that third-party exploits of module admin are very hard to pull off, and
indeed can only happen if the admin transaction calls into third-party code
which is ready to enact the exploit (which would fail in any normal transaction
and draw attention to itself, as there is no way to detect that module admin is
acquired).

Finally, this firmly sounds the alarm that putting module-admin credentials in a
transaction is a highly sensitive operation which should not call 3rd party code
if it can help it, and instead wait for a safe transaction in which to do so.

## Runtime Safety

### Termination

Pact code is guaranteed to terminate by

- not allowing anonymous lambdas -- all lambdas must be declared in module code
- resolving all references at module load, failing on any cycle

However, there are two cases where a module can execute "dynamic" code that has
not been previously resolved at runtime:

1. **Keyset predicate evaluation**. Custom keyset predicates are stored as a
   bare string and evaluated in `enforce-keyset` as an application of the
   indicated function.
2. **User guard evaluation**. User guards can be read from the database or
   constructed externally, and are evaluated by-name as the application of the
   indicated function.

In both cases, they are run in a special context that tests the call stack for a
repeated occurrence of the application function name, and fails if found.

Thus Pact enforces termination in all cases.

### Safety in evaluation of _g_

The guard function _g_, when evaluated, runs as a "normal" application of _d_ as
a function with _P_ for arguments. The invariants for safe execution of this
function are:

#### Termination

Generally this is implied by being a "normal" application in a module, thus as
standard Pact module code.

#### Acquire and "manual" install (`install-capability`) in-module only.

The ability to bring a capability into scope, either managed or call-stack, is
restricted to in-module code only.

For acquisition, this guarantees that any state-mutating code guarded by
`with-capability` cannot escape the confines of the declaring module. Otherwise,
the authority granted by the capability is unknowable.

For installation, this ensures that the scenarios in which a managed capability
is installed are only:

1. Module code controlled by the author
2. Installation via inclusion in _W_.

#2 is essential as it allows the end-user who might be affected by the
capability to control how and if it is installed. Obviously, #2 will fail if for
some reason this install cannot be achieved.

As "unscoped" capabilities, the goal here is to prevent a capability from being
installed by untrusted code. Having said that, examples of safe usages of #1 are
not known at this time, but the in-module restriction means that if one emerges,
it's possible, and otherwise module authors can simply avoid it. (It is also
useful for testing to install capabilities by acquiring module admin).

#### Prevention of acquire or install.

Acquire or install of _c\* d_ both change the state of _R_:

- acquire pushes a slot for _c\* d_ onto \_S<sub>A</sub>.
- install adds a slot for _c\* d_ to _S<sub>M</sub>_ and adds _c\* d_ to "seen"
  _C\*<sub>M</sub>_.

If during this operation, a nested acquire or install were to happen:

1. A nested install within an outer acquire would **violate the scope implied by
   the outer acquire**, as the nested install would persist after the outer
   acquire goes out of scope.
2. A nested install within an outer install has no obvious defects.
3. A nested acquire in an outer acquire would allow protected state-mutating
   activity scoped by the nested acquire to occur, while we were trying to see
   if we can acquire the outer capability, presumably guarding some other
   state-mutating activity. Reasoning about state in this scenario is
   unsatisfying at a minimum and possibly incoherent. It is if nothing else
   inelegant, although the stack scope would probably be unharmed.
4. A nested acquire within an outer install has the same concerns as #2 about
   executing some state-modifying activity in the body of the install.

Since some issue above applies in either nested install (#1) or acquire (#3,
#4), install and acquire are prevented while executing _g_. This is accomplished
by testing for a `defcap` in the call stack when either `install-capability` or
`require-capability` are invoked.

Obviously, this is what `compose-capability` is for, importing some other
capability into the scope of the outer capability. `compose-capability` has the
reverse invariant that it can only be invoked within a `defcap` execution, using
the same call-stack-checking mechanism.

#### Safety of `require-capability`

`require-capability` does not affect _R_, as it simply fails if it does not find
the indicated capability in _S<sub>A</sub>_. It also does not mutate state.

It is therefore safe in any context, acquire or install, as requiring within _g_
does not produce any unwanted effects. It is more logical to compose instead of
require in _g_, but it is otherwise harmless, and there are perhaps scenarios
where testing without acquiring is correct. Plus as we will see, require is
useful in user guards, which may be tested in the context of _g_.

This is a happy conclusion, as requiring capabilities in user guards are useful
for certain scenarios, like allowing modules to pay gas for some external user:
the external user can indicate some account that is controlled by a user guard
that tests for a capability in the foreign module, which has been installed by
the external user in _W_.

### Safety in dynamic code

As noted above, there are two places where code is dynamically evaluated. While
user guards are the more relevant case, anything said about user guards can
easily apply to keyset predicates, as they execute in identical contexts:

- The evaluation context is **pure**, which means the code cannot mutate state.
- As noted above, termination is operationally guaranteed.

#### Acquire/install unsafe in dynamic code

As acquire and install cause execution of _g_, they are unsafe in dynamic code:

1. **Unsafe failures due to purity violations.** Dynamic code is run in a pure
   context, whereas _g_ is not thus restricted. The outer context of dynamic
   execution will cause impure code in _g_ to fail.

2. **Unsafe failures if evaluated in _g_**. If _g_ tests a user guard or keyset
   predicate that attempts to acquire or install, the dynamic code will fail due
   to the restrictions above on acquire or install in _g_.

TODO: this is not enforced currently. Dynamic code should be noted as such in
the call stack, so that it can be detected and always fail upon embedded acquire
or install.

#### "Semantic safety"

Note that here, "unsafe" refers to a slightly different notion of safety which
we will call "semantic safety": an unexpected failure in dynamic code renders
the intention of the dynamic code inoperable, in a way that would otherwise be
undetectable during module load and potentially testing. In other words, the
real safety here is **totality**, where the cases of the dynamic code failing
are feasible to enumerate.

This note is here because "safety" when talking about capabilities often refers
to avoiding exploits like privilege escalation. In this context it is more about
having total semantics for a user guard or keyset predicate.

#### Require safe in dynamic code

For the same reasons that require is safe in _g_, it is safe in dynamic code:

- Purity is ensured, as require is pure and without any effects on the
  capability state.
- Termination and "semantic safety" are ensured, as _g_ is never invoked when
  requiring.

### Notes on runtime vs compile-time safety

None of the enforcements in this section are currently detected at compile time,
as there is no type-level representation of capabilities to guide it; while
Pact's compilation could detect immediate violations, it cannot detect
violations in linked code, even if it is in the same module. Therefore it is not
currently possible to do this.

Instead, runtime guarantees ensure that simple coverage of impacted code will
immediately cause failure if these invariants are violated.
