# commandBuilder

---

`commandBuilder` assists in constructing commands by the utilities that use
definition files generated by pact-generator. This enables flawless code
completion.

`commandBuilder` accepts partial PactCommands or reducer functions that return
partial PactCommands, providing the necessary flexibility for various scenarios.
The return value of commandBuilder is a merged object of partial PactCommands,
allowing you to compose commandBuilder to generate the desired command.

<details>
<summary>commandBuilder return type</summary>

```TypeScript
export interface ICommandBuilderReturnType {
  /**
   * command generator function, useful when you what to compose multiple command builders or use it with FP utilities (e.g. pipe)
   */
  (initial: Partial<IPactCommand>): Partial<IPactCommand>;
  /**
   * Returns the merged IPactCommand Object
   */
  getPactCommand(): Partial<IPactCommand>;
  /**
   * Returns transaction including { cmd, hash, sigs }, in this step sig would be an array of undefined values that you need to add signatures later
   */
  getTransaction(): IUnsignedCommand;
  /**
   * validate the command to see if it has all required parts
   */
  validate(): boolean;
}
```

</details>

<details>
<summary>examples</summary>

Merging all partial objects to one object

```TypeScript
const command = commandBuilder(
  { payload: { code: '(coin.transfer "alice" "bob" 1)' } },
  { payload: { data: { key: 'value' } } },
  (cmd) => ({ nonce: createNonce(cmd) }),
).getCommand()

// command
const cmd = {
  payload: {
    code: '(coin.transfer "alice" "bob" 1)',
    data: { key: 'value' },
  },
  nonce: 'result-of-createNonce',
};
```

Compose multiple commandBuilder

```TypeScript
const mainnetConfig = commandBuilder(
  setMeta({ chainId: '1' }),
  setProp('networkId', 'mainnet04'),
);

const transfer = commandBuilder(
  payload.exec(coin.transfer('javad', 'albert', { decimal: '0.1' })),
  addSigner('javadPublicKey', (withCapability) => [
    withCapability('coin.GAS'),
    withCapability('coin.TRANSFER', 'javad', 'albert', { decimal: '0.1' }),
  ]),
);

const finalCommand = commandBuilder(mainnetConfig, transfer).getPactCommand();

```

</details>

The library also exports some helpers to facilitate easier creation of each
section of the command.

## `payload.exec`

creating exec payload

<details>
<summary>examples</summary>

```TypeScript
import Pact from "@kadena/client"

// importing coin module that you can generate types of that by using "pactjs-cli"
const { coin } = Pact.modules;

const command = commandBuilder(
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  )
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  }
}
```

</details>

## `payload.cont`

creating continuation command

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder(
  payload.cont({
    pactId: '1',
    proof: 'test-proof',
    step: '1',
  })
).getPactCommand()

//
const command = {
  payload: {
    pactId: '1',
    proof: 'test-proof',
    step: '1',
  }
}
```

</details>

## `addSigner`

add a signer and capabilities they sign for, to the command it also uses the the
typing from the payload part and recommends the relevant capabilities

| parameter          | type                                                                       | description                                                                                |
| ------------------ | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| signer             | string \| { pubKey: string; scheme?: 'ED25519' \| 'ETH', address?:string } | public key of the signer or object including publicKey, schema, and address                |
| capabilityCallBack | (withCapability)=> ICapabilityItem[]                                       | it gives withCapability function to users in order to add capabilities to the signer part. |

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  ),
  addSigner("bob_public_key",(withCapability)=>[
    withCapability("coin.TRANSFER", "bob", "alice", { decimal: "1.1" })
  ])
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  signers:[
    {
      pubKey: "bob_public_key",
      schema: "ED25519"
      clist:[{
        name: "coin.TRANSFER",
        args:['"bob"', '"alice"', "1.1"]
      }]
    }
  ]
}

```

</details>

## `readKeyset`

return `(read-keyset "name")` string, useful when generating code.

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer(readKeyset("sender_key"), "bob", { decimal: "1.1" })
  ),
).getPactCommand()

//
const command = {
  payload: {
    code : `(coin.transfer (read-keyset "sender_key") "bob" 1.1)`
  }
}

```

</details>

## `addData`

adds data to the payload part

| parameter | type                                  | description                         |
| --------- | ------------------------------------- | ----------------------------------- |
| name      | string                                | name of the data that you can refer |
| data      | object \| string \| number \| boolean | The data you want to add            |

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder (
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  ),
  addData("name", { value: "test" }),
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
    data: {
      name : {
        value : "test"
      }
    }
  },
}

```

</details>

## `addKeyset`

add keyset to the data part

| parameter     | type                                             | description                                  |
| ------------- | ------------------------------------------------ | -------------------------------------------- |
| name          | string                                           | name of the keyset                           |
| pred          | "keys-all" \| "keys-one" \| "keys-two" \| string | type of pred                                 |
| ...publicKeys | string[]                                         | list of the public keys to add to the keyset |

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer(readKeyset("senderKey"), "bob", { decimal: "1.1" })
  ),
  addKeyset("senderKey","keys-one", "the_public_key")
).getPactCommand()

//
const command = {
  payload: {
    code: `(coin.transfer (read-keyset "sender_key") "bob" 1.1)`
    data: {
      senderKey: {
        publicKeys: ['the_public_key'],
        pred: "keys-one"
      }
    }
  }
}

```

</details>

## `setMeta`

returns meta section of the command

<details>
<summary>examples</summary>

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer("alice", "bob", { decimal: "1.1" })
  ),
  setMeta({ chainId : "1" }),
).getPactCommand()

//
const command = {
   payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  meta:{
    chianId: "1",
    gasLimit: 2500,
    gasPrice: 1.0e-8,
    sender: '',
    ttl: 8 * 60 * 60, // 8 hours,
    creationTime: Math.floor(Date.now() / 1000),
  }
}
```

</details>

## `setProp`

A general helper to add a section.

<details>

<summary>examples</summary>

```TypeScript

const command = commandBuilder(
  payload.exec(
    coin.transfer("alice", "bob", { decimal: "1.1" })
  ),
  setProp("networkId", "mainnet01"),
  setProp("nonce", `k:none:${Date.now()}`),
).getPactCommand()

//
const command = {
   payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  networkId: "mainnet01",
  nonce: "k:none:1232123123",
}

```

</details>
