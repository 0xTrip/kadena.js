# kadena@client

Core library for building Pact expressions to send to the blockchain in js.
Makes use of .kadena/pactjs-generated

<p align="center">

<picture>

<source srcset="https://github.com/kadena-community/kadena.js/raw/master/common/images/Kadena.JS_logo-white.png" media="(prefers-color-scheme: dark)"/>

<img src="https://github.com/kadena-community/kadena.js/raw/master/common/images/Kadena.JS_logo-black.png" width="200" alt="kadena.js logo" />

</picture>

</p>

<hr>

API Reference can be found here
[client.api.md](https://github.com/kadena-community/kadena.js/tree/master/packages/libs/client/etc/client.api.md)

<hr>

## Introduction

kadena@client s a library that helps web developers interact with the Kadena
blockchain. It includes three main modules that can be used separately or
together.

- commandBuilder
- sign
- getClient

## commandBuilder

---

`commandBuilder` assists in constructing commands by the utilities that use
definition files generated by pact-generator. This enables flawless code
completion.

`commandBuilder` accepts partial PactCommands or reducer functions that return
partial PactCommands, providing the necessary flexibility for various scenarios.
The return value of commandBuilder is a merged object of partial PactCommands,
allowing you to compose commandBuilder to generate the desired command.

command builder returns these properties

```TypeScript
export interface ICommandBuilderReturnType {
  /**
   * command generator function, useful when you what to compose multiple command builders or use it with FP utilities (e.g. pipe)
   */
  (initial: Partial<IPactCommand>): Partial<IPactCommand>;
  /**
   * Returns the merged IPactCommand Object
   */
  getPactCommand(): Partial<IPactCommand>;
  /**
   * Returns transaction including { cmd, hash, sigs }, in this step sig would be an array of undefined values that you need to add signatures later
   */
  getTransaction(): IUnsignedCommand;
  /**
   * validate the command to see if it has all required parts
   */
  validate(): boolean;
}
```

### examples

Merging all partial objects to one object

```TypeScript
const command = commandBuilder(
  { payload: { code: '(coin.transfer "alice" "bob" 1)' } },
  { payload: { data: { key: 'value' } } },
  (cmd) => ({ nonce: createNonce(cmd) }),
).getCommand()

// command
const cmd = {
  payload: {
    code: '(coin.transfer "alice" "bob" 1)',
    data: { key: 'value' },
  },
  nonce: 'result-of-createNonce',
};
```

Compose multiple commandBuilder

```TypeScript
const mainnetConfig = commandBuilder(
  setMeta({ chainId: '1' }),
  setProp('networkId', 'mainnet04'),
);

const transfer = commandBuilder(
  payload.exec(coin.transfer('javad', 'albert', { decimal: '0.1' })),
  addSigner('javadPublicKey', (withCapability) => [
    withCapability('coin.GAS'),
    withCapability('coin.TRANSFER', 'javad', 'albert', { decimal: '0.1' }),
  ]),
);

const finalCommand = commandBuilder(mainnetConfig, transfer).getPactCommand();

```

The library also exports some helpers to facilitate easier creation of each
section of the command.

### `payload.exec`

creating exec payload

```TypeScript

import Pact from "@kadena/client"

// importing coin module that you can generate types of that by using "pactjs-cli"
const { coin } = Pact.modules;

const command = commandBuilder(
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  )
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  }
}
```

### `payload.cont`

creating continuation command

```TypeScript
const command = commandBuilder(
  payload.cont({
    pactId: '1',
    proof: 'test-proof',
    step: '1',
  })
).getPactCommand()

//
const command = {
  payload: {
    pactId: '1',
    proof: 'test-proof',
    step: '1',
  }
}
```

### `addSigner`

add a signer and capabilities they sign for, to the command it also uses the the
typing from the payload part and recommends the relevant capabilities

| parameter          | type                                                                       | description                                                                                |
| ------------------ | -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| signer             | string \| { pubKey: string; scheme?: 'ED25519' \| 'ETH', address?:string } | public key of the signer or object including publicKey, schema, and address                |
| capabilityCallBack | (withCapability)=> ICapabilityItem[]                                       | it gives withCapability function to users in order to add capabilities to the signer part. |

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  ),
  addSigner("bob_public_key",(withCapability)=>[
    withCapability("coin.TRANSFER", "bob", "alice", { decimal: "1.1" })
  ])
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  signers:[
    {
      pubKey: "bob_public_key",
      schema: "ED25519"
      clist:[{
        name: "coin.TRANSFER",
        args:['"bob"', '"alice"', "1.1"]
      }]
    }
  ]
}

```

### `readKeyset`

return `(read-keyset "name")` string, useful when generating code.

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer(readKeyset("sender_key"), "bob", { decimal: "1.1" })
  ),
).getPactCommand()

//
const command = {
  payload: {
    code : `(coin.transfer (read-keyset "sender_key") "bob" 1.1)`
  }
}

```

### `addData`

adds data to the payload part

| parameter | type                                  | description                         |
| --------- | ------------------------------------- | ----------------------------------- |
| name      | string                                | name of the data that you can refer |
| data      | object \| string \| number \| boolean | The data you want to add            |

```TypeScript
const command = commandBuilder (
  payload.exec(
    coin.transfer("bob", "alice", { decimal: "1.1" })
  ),
  addData("name", { value: "test" }),
).getPactCommand()

//
const command = {
  payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
    data: {
      name : {
        value : "test"
      }
    }
  },
}

```

### `addKeyset`

add keyset to the data part

| parameter     | type                                             | description                                  |
| ------------- | ------------------------------------------------ | -------------------------------------------- |
| name          | string                                           | name of the keyset                           |
| pred          | "keys-all" \| "keys-one" \| "keys-two" \| string | type of pred                                 |
| ...publicKeys | string[]                                         | list of the public keys to add to the keyset |

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer(readKeyset("senderKey"), "bob", { decimal: "1.1" })
  ),
  addKeyset("senderKey","keys-one", "the_public_key")
).getPactCommand()

//
const command = {
  payload: {
    code: `(coin.transfer (read-keyset "sender_key") "bob" 1.1)`
    data: {
      senderKey: {
        publicKeys: ['the_public_key'],
        pred: "keys-one"
      }
    }
  }
}

```

### `setMeta`

returns meta section of the command

```TypeScript
const command = commandBuilder(
  payload.exec(
    coin.transfer("alice", "bob", { decimal: "1.1" })
  ),
  setMeta({ chainId : "1" }),
).getPactCommand()

//
const command = {
   payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  meta:{
    chianId: "1",
    gasLimit: 2500,
    gasPrice: 1.0e-8,
    sender: '',
    ttl: 8 * 60 * 60, // 8 hours,
    creationTime: Math.floor(Date.now() / 1000),
  }
}
```

### `setProp`

A general helper to add a section.

```TypeScript

const command = commandBuilder(
  payload.exec(
    coin.transfer("alice", "bob", { decimal: "1.1" })
  ),
  setProp("networkId", "mainnet01"),
  setProp("nonce", `k:none:${Date.now()}`),
).getPactCommand()

//
const command = {
   payload: {
    code: '(coin.transfer "bob" "alice" 1.1)'
  },
  networkId: "mainnet01",
  nonce: "k:none:1232123123",
}

```

## getClient

---

Returns the client helpers in order to send commands to the blockchain and poll
status of requests

| parameter              | type                                                 | description                                                                                                                                                                       |
| ---------------------- | ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| host\|hostApiGenerator | string \| (networkId:string, chainId:string)=>string | the url of the blockchian host or the url generator that accepts `networkId` and `chianId` the default value is kadenaHostGenerator that generates url for mainnet01 or testnet04 |

Using hostUrl or hostUrlGenerator

```TypeScript
// we only want to send request to the chain 1 one the mainnet
const hostUrl = "https://api.chainweb.com/chainweb/0.0/mainnet01/chain/1/pact"
const client = getClient(hostUrl)
// we need more flexibitly to call diferent chain or even network, then function
// extract networkId and chainId from the cmd part of a transaction and use the function to generate the url
const hostUrlGenerator = (networkId,chainId) => `https://api.chainweb.com/chainweb/0.0/${networkId}/chain/${chainId}/pact`
const client = getClient(hostUrlGenerator)
```

the helpers

```TypeScript
const hostUrlGenerator = (networkId,chainId) => `https://api.chainweb.com/chainweb/0.0/${networkId}/chain/${chainId}/pact`
const { local , submit, getStatus, pollStatus, getSpv, pollSpv } = getClient(hostUrlGenerator)
```

### local

This function calls `/local` endpoint of the blockchain, actually its a dirty
read and does not submit any changes to blockchain (so you don't pay gas)

| parameter | type | description |
| --------- | ---- | ----------- |

| transaction

```TypeScript
const unSignedTr = commandBuilder(...).createTransaction()
// if you need to sign the tr
const signedTr = await quicksign(unSignedTr)
// return the request key that you can use later fro fetching the request status
const requestKey = await local(signedTr)
```

### submit

this function
